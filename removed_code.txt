# def calculate_initial_movement_direction_error(
#     kinData,
#     HandX_filt,
#     HandY_filt,
#     xTargetPos,
#     yTargetPos,
#     i,
#     subject,
#     CursorX,
#     CursorY,
#     velX_filt,
#     velY_filt,
#     defaults  # Pass the defaults to access sampling frequency
# ):
#     # Check if RT is NaN
#     if np.isnan(kinData['RT']):
#         kinData['IDE'] = np.nan
#         kinData['x_intersect'] = np.nan
#         kinData['x_target_at_RT'] = np.nan
#         return kinData
#     # print(1/0)
#     # Reaction time index
#     RT = int(kinData['RT'])

#     # Get hand position and velocity at RT
#     x_rt = HandX_filt[RT]
#     y_rt = HandY_filt[RT]
#     v_x_rt = velX_filt[RT]
#     v_y_rt = velY_filt[RT]

#     # Get target y position at RT
#     y_target_at_RT = yTargetPos[RT]

#     # Store x_target_at_RT for regression
#     kinData['x_target_at_RT'] = xTargetPos[RT]

#     # Compute t_intersect
#     if v_y_rt != 0:
#         t_intersect = (y_target_at_RT - y_rt) / v_y_rt

#         # Calculate x_intersect
#         x_intersect = x_rt + v_x_rt * t_intersect

#         kinData['x_intersect'] = x_intersect
#     else:
#         # If v_y_rt is zero, cannot compute intersection
#         kinData['x_intersect'] = np.nan

#     # Now, compute IDE (Initial Direction Error)

#     # The ideal movement vector is from start position to target position at RT
#     start_x = HandX_filt[0]
#     start_y = HandY_filt[0]
#     target_x = xTargetPos[RT]
#     target_y = yTargetPos[RT]
#     ideal_vector = np.array([target_x - start_x, target_y - start_y])

#     # The actual movement vector is from start position to hand position at RT + 50 ms
#     RT_50 = RT + int(50 / (1000 / defaults['fs']))  # Convert 50 ms to samples

#     if RT_50 >= len(HandX_filt):
#         RT_50 = len(HandX_filt) - 1

#     actual_vector = np.array([HandX_filt[RT_50] - start_x, HandY_filt[RT_50] - start_y])

#     # Calculate angle between vectors
#     determinant = actual_vector[0] * ideal_vector[1] - actual_vector[1] * ideal_vector[0]
#     dot_product = actual_vector[0] * ideal_vector[0] + actual_vector[1] * ideal_vector[1]
#     theta_rad = np.arctan2(determinant, dot_product)
#     theta_deg = np.degrees(theta_rad)

#     kinData['IDE'] = theta_deg if not np.isnan(theta_deg) else np.nan

#     return kinData

# def calculate_initial_movement_direction_error(
#     kinData,
#     HandX_filt,
#     HandY_filt,
#     xTargetPos,
#     yTargetPos,
#     i,
#     subject,
#     CursorX,
#     CursorY,
#     velX_filt,
#     velY_filt,
#     window_size=10  # Define the window size around RT+50
# ):
#        # Check if RT is NaN
#     if np.isnan(kinData['RT']):
#         kinData['IDE'] = np.nan
#         kinData['x_intersect'] = np.nan
#         kinData['x_target_at_RT'] = np.nan
#         return kinData

#     # Define the primary reaction time index
#     reaction_time = int(kinData['RT'])
#     reaction_time_50 = int(kinData['RT'] + 50)

#     # Define the window around RT+50
#     window_start = reaction_time_50 - window_size
#     window_end = reaction_time_50 + window_size

#     # Ensure window boundaries are within data limits
#     max_length = min(len(HandX_filt), len(xTargetPos))
#     window_start = max(reaction_time, window_start)
#     window_end = min(window_end, max_length - 1)

#     # Initialize lists to store x_intersect candidates
#     x_intersect_candidates = []
#     valid_indices = []

#     for t in range(window_start, window_end + 1):
#         # Calculate deltas
#         delta_x = HandX_filt[t] - HandX_filt[reaction_time]
#         delta_y = HandY_filt[t] - HandY_filt[reaction_time]

#         # Avoid division by zero
#         if delta_x == 0:
#             slope = np.inf
#         else:
#             slope = delta_y / delta_x

#         # Get the target Y position at current time point
#         y_target_plane = yTargetPos[t]

#         # Calculate x_intersect based on slope
#         if np.isfinite(slope) and slope != 0:
#             # Compute x_intersect where the movement line intersects y_target_plane
#             x_intersect = HandX_filt[reaction_time] + (y_target_plane - HandY_filt[t]) / slope
#         else:
#             # If slope is infinite or zero, set x_intersect to HandX at reaction time
#             x_intersect = HandX_filt[reaction_time]

#         x_intersect_candidates.append(x_intersect)
#         valid_indices.append(t)

#     # Select the most meaningful x_intersect from candidates
#     if x_intersect_candidates:
#         # Criteria for selection:
#         # Here, we choose the median x_intersect to reduce the influence of any remaining outliers
#         selected_x_intersect = np.median(x_intersect_candidates)
        
#         # Optionally, you can choose the x_intersect corresponding to the median time point
#         # median_index = valid_indices[np.argsort(x_intersect_candidates)[len(x_intersect_candidates) // 2]]
#         # selected_x_intersect = x_intersect_candidates[len(x_intersect_candidates) // 2]

#         # Assign selected x_intersect
#         kinData['x_intersect'] = selected_x_intersect

#         # Assign x_target_at_RT using the selected time point
#         # Find the closest time index to the window's center
#         center_time = reaction_time_50
#         closest_time = min(valid_indices, key=lambda x: abs(x - center_time))
#         kinData['x_target_at_RT'] = xTargetPos[closest_time]
#     else:
#         # If no valid x_intersect found within the window, assign NaN
#         kinData['x_intersect'] = np.nan
#         kinData['x_target_at_RT'] = np.nan

#     # After selecting x_intersect, calculate IDE

#     # Define start and target positions
#     start_x = HandX_filt[0]
#     start_y = HandY_filt[0]

#     if not np.isnan(kinData['x_intersect']) and not np.isnan(kinData['x_target_at_RT']):
#         target_x = kinData['x_intersect']
#         target_y = yTargetPos[closest_time]

#         # Compute ideal and actual movement vectors
#         ideal_vector = np.array([target_x - start_x, target_y - start_y])
#         actual_vector = np.array([HandX_filt[closest_time] - start_x, HandY_filt[closest_time] - start_y])

#         # Adjust for target direction if necessary
#         if target_x < 0:
#             ideal_vector = np.array([-ideal_vector[0], ideal_vector[1]])
#             actual_vector = np.array([-actual_vector[0], actual_vector[1]])

#         # Calculate angle between vectors using arctan2 of determinant and dot product
#         determinant = actual_vector[0] * ideal_vector[1] - actual_vector[1] * ideal_vector[0]
#         dot_product = actual_vector[0] * ideal_vector[0] + actual_vector[1] * ideal_vector[1]
#         theta_rad = np.arctan2(determinant, dot_product)
#         theta_deg = np.degrees(theta_rad)

#         kinData['IDE'] = theta_deg if not np.isnan(theta_deg) else np.nan
#     else:
#         kinData['IDE'] = np.nan

#     return kinData
